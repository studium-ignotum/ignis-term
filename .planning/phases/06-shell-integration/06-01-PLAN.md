---
phase: 06-shell-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shell-integration/init.zsh
  - shell-integration/init.bash
  - shell-integration/init.fish
autonomous: true

must_haves:
  truths:
    - "Sourcing init.zsh in a shell sends registration to mac-client"
    - "Sourcing init.bash in a shell sends registration to mac-client"
    - "Sourcing init.fish in a shell sends registration to mac-client"
    - "Session stays active while shell is running"
    - "When mac-client not running, script completes silently under 100ms"
  artifacts:
    - path: "shell-integration/init.zsh"
      provides: "Zsh shell integration"
      min_lines: 50
      contains: "add-zsh-hook"
    - path: "shell-integration/init.bash"
      provides: "Bash shell integration"
      min_lines: 40
      contains: "PROMPT_COMMAND"
    - path: "shell-integration/init.fish"
      provides: "Fish shell integration"
      min_lines: 40
      contains: "--on-event"
  key_links:
    - from: "shell-integration/init.zsh"
      to: "/tmp/terminal-remote.sock"
      via: "nc -U socket connection"
      pattern: "nc.*-U.*/tmp/terminal-remote"
    - from: "shell-integration/init.bash"
      to: "/tmp/terminal-remote.sock"
      via: "nc -U socket connection"
      pattern: "nc.*-U.*/tmp/terminal-remote"
    - from: "shell-integration/init.fish"
      to: "/tmp/terminal-remote.sock"
      via: "nc -U socket connection"
      pattern: "nc.*-U.*/tmp/terminal-remote"
---

<objective>
Create shell integration scripts for zsh, bash, and fish that connect terminal sessions to mac-client via Unix domain socket.

Purpose: Enable any terminal session to register with mac-client for remote access, fulfilling the universal terminal support goal of v2.0.

Output: Three init scripts in shell-integration/ directory ready for installation to ~/.terminal-remote/
</objective>

<execution_context>
@/Users/nat/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nat/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-shell-integration/06-CONTEXT.md
@.planning/phases/06-shell-integration/06-RESEARCH.md
@.planning/phases/05-mac-client/05-03-SUMMARY.md
@mac-client/src/ipc/session.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zsh integration script</name>
  <files>shell-integration/init.zsh</files>
  <action>
Create `shell-integration/init.zsh` with the following functionality:

**Configuration:**
- Socket path: `/tmp/terminal-remote.sock`
- Session name format: `${PWD##*/} [$$]` (directory basename + PID)

**Core functions:**
1. `_terminal_remote_session_name()` - Returns "dirname [PID]" format
2. `_terminal_remote_json_escape()` - Escapes strings for JSON (backslash, quote, newline, tab)
3. `_terminal_remote_connect()` - Attempts socket connection with background nc process

**Connection approach (persistent background process):**
- Use a coprocess or background subshell that holds the socket open
- Send registration JSON: `{"name":"...","shell":"zsh","pid":$$}`
- Keep nc running in background with `cat` blocking on its stdin
- Store background PID in `_TERMINAL_REMOTE_BG_PID`

**Startup logic:**
```zsh
_terminal_remote_init() {
  # Fast check: socket file exists?
  [[ -S "$_TERMINAL_REMOTE_SOCKET" ]] || return 0

  _terminal_remote_connect
  if (( _TERMINAL_REMOTE_CONNECTED )); then
    echo "Connected to Terminal Remote"
  fi
}
```

**Exit cleanup:**
```zsh
_terminal_remote_zshexit() {
  (( _TERMINAL_REMOTE_CONNECTED )) || return
  # Kill background process holding socket
  [[ -n "$_TERMINAL_REMOTE_BG_PID" ]] && kill "$_TERMINAL_REMOTE_BG_PID" 2>/dev/null
}
```

**Register hooks using add-zsh-hook:**
```zsh
autoload -Uz add-zsh-hook
# zshexit is not a hook, define function directly
zshexit() { _terminal_remote_zshexit }
```

**Important implementation notes:**
- Use `&!` (background + disown) for fire-and-forget operations
- Suppress all error output to stderr (2>/dev/null)
- The socket existence check is instant (filesystem stat)
- Do NOT add precmd/chpwd hooks that do socket I/O (latency)
  </action>
  <verify>
Run: `zsh -c 'source shell-integration/init.zsh && echo $_TERMINAL_REMOTE_SOCKET'` outputs `/tmp/terminal-remote.sock`

Verify functions exist: `zsh -c 'source shell-integration/init.zsh && typeset -f _terminal_remote_session_name'` shows function definition
  </verify>
  <done>
init.zsh exists with connection logic, JSON escaping, exit cleanup. Functions load without errors. Socket path constant defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Bash integration script</name>
  <files>shell-integration/init.bash</files>
  <action>
Create `shell-integration/init.bash` with equivalent functionality to init.zsh:

**Configuration:**
- Same socket path and session name format
- Use `$$` for PID (works in bash)

**Core functions (bash syntax):**
1. `_terminal_remote_session_name()` - Same logic, bash-compatible
2. `_terminal_remote_json_escape()` - Use bash string substitution
3. `_terminal_remote_connect()` - Background process approach

**Connection approach:**
```bash
_terminal_remote_connect() {
  local name
  name=$(_terminal_remote_json_escape "$(_terminal_remote_session_name)")
  local msg="{\"name\":\"${name}\",\"shell\":\"bash\",\"pid\":$$}"

  # Background process: send registration and keep connection open
  {
    echo "$msg"
    # Block forever (connection stays open until killed)
    cat
  } | nc -U "$_TERMINAL_REMOTE_SOCKET" 2>/dev/null &
  _TERMINAL_REMOTE_BG_PID=$!
  disown $_TERMINAL_REMOTE_BG_PID 2>/dev/null
  _TERMINAL_REMOTE_CONNECTED=1
}
```

**Exit cleanup using trap:**
```bash
_terminal_remote_cleanup() {
  [[ $_TERMINAL_REMOTE_CONNECTED -eq 1 ]] || return
  [[ -n "$_TERMINAL_REMOTE_BG_PID" ]] && kill "$_TERMINAL_REMOTE_BG_PID" 2>/dev/null
}
trap '_terminal_remote_cleanup' EXIT
```

**Startup:**
```bash
_terminal_remote_init() {
  [[ -S "$_TERMINAL_REMOTE_SOCKET" ]] || return 0
  _terminal_remote_connect
  [[ $_TERMINAL_REMOTE_CONNECTED -eq 1 ]] && echo "Connected to Terminal Remote"
}
_terminal_remote_init
```

**Important:**
- Use `( ... ) &` subshell for cleaner backgrounding
- `disown` prevents job completion messages
- Test with both bash 3.2 (macOS default) and bash 5.x
  </action>
  <verify>
Run: `bash --norc -c 'source shell-integration/init.bash && echo $_TERMINAL_REMOTE_SOCKET'` outputs `/tmp/terminal-remote.sock`

Check function: `bash --norc -c 'source shell-integration/init.bash && type _terminal_remote_session_name'`
  </verify>
  <done>
init.bash exists with connection logic, JSON escaping, EXIT trap. Functions load without errors in bash 3.2+.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Fish integration script</name>
  <files>shell-integration/init.fish</files>
  <action>
Create `shell-integration/init.fish` with fish shell syntax:

**Configuration:**
```fish
set -g _TERMINAL_REMOTE_SOCKET "/tmp/terminal-remote.sock"
set -g _TERMINAL_REMOTE_CONNECTED 0
set -g _TERMINAL_REMOTE_PID %self
set -g _TERMINAL_REMOTE_BG_PID ""
```

**Core functions (fish syntax):**
1. `_terminal_remote_session_name` - Use `basename $PWD` and `%self`
2. `_terminal_remote_json_escape` - Use `string replace` for escaping
3. `_terminal_remote_connect` - Fish backgrounding

**JSON escape in fish:**
```fish
function _terminal_remote_json_escape
  string replace -a '\\' '\\\\' -- $argv[1] | \
  string replace -a '"' '\\"' | \
  string replace -a \n '\\n' | \
  string replace -a \t '\\t'
end
```

**Connection:**
```fish
function _terminal_remote_connect
  set -l name (_terminal_remote_json_escape (_terminal_remote_session_name))
  set -l msg "{\"name\":\"$name\",\"shell\":\"fish\",\"pid\":$_TERMINAL_REMOTE_PID}"

  # Use fish's job control for background process
  begin
    echo $msg
    cat  # Block to keep connection open
  end | nc -U "$_TERMINAL_REMOTE_SOCKET" 2>/dev/null &
  set -g _TERMINAL_REMOTE_BG_PID (jobs -lp | tail -1)
  disown $__terminal_remote_bg_pid 2>/dev/null
  set -g _TERMINAL_REMOTE_CONNECTED 1
end
```

**Exit cleanup using fish event:**
```fish
function _terminal_remote_cleanup --on-event fish_exit
  test $_TERMINAL_REMOTE_CONNECTED -eq 1; or return
  test -n "$_TERMINAL_REMOTE_BG_PID"; and kill $_TERMINAL_REMOTE_BG_PID 2>/dev/null
end
```

**Startup:**
```fish
function _terminal_remote_init
  test -S "$_TERMINAL_REMOTE_SOCKET"; or return 0
  _terminal_remote_connect
  test $_TERMINAL_REMOTE_CONNECTED -eq 1; and echo "Connected to Terminal Remote"
end

_terminal_remote_init
```

**Important fish-specific notes:**
- Use `%self` for current shell PID
- `set -g` for global variables
- `string replace` for string manipulation
- `--on-event fish_exit` for exit handler
  </action>
  <verify>
Run: `fish -c 'source shell-integration/init.fish && echo $_TERMINAL_REMOTE_SOCKET'` outputs `/tmp/terminal-remote.sock`

Check function: `fish -c 'source shell-integration/init.fish && functions _terminal_remote_session_name'`
  </verify>
  <done>
init.fish exists with connection logic, JSON escaping, fish_exit event handler. Functions load without errors in fish 3.0+.
  </done>
</task>

</tasks>

<verification>
All scripts load without errors in their respective shells:
- `zsh -c 'source shell-integration/init.zsh'` exits 0
- `bash --norc -c 'source shell-integration/init.bash'` exits 0
- `fish -c 'source shell-integration/init.fish'` exits 0

Scripts define required functions:
- Session name function returns "dirname [PID]" format
- JSON escape handles quotes and backslashes
- Connect function is defined

Socket path constant is /tmp/terminal-remote.sock in all scripts.
</verification>

<success_criteria>
1. shell-integration/ directory contains init.zsh, init.bash, init.fish
2. Each script loads without errors in its shell
3. Each script has: socket path constant, session name function, JSON escape, connect function, exit cleanup
4. When socket doesn't exist, scripts complete immediately (no delay)
5. Scripts use background processes for connection (don't block shell)
</success_criteria>

<output>
After completion, create `.planning/phases/06-shell-integration/06-01-SUMMARY.md`
</output>
